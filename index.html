<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>英語読み上げサイト</title>
    <!-- Tailwind CSSを読み込む -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* ダークグレーの背景 */
        }
        /* カテゴリトグルアイコンの回転アニメーション */
        .category-toggle-icon {
            transition: transform 0.2s ease-in-out;
        }
        .category-toggle-icon.rotate-180 {
            transform: rotate(180deg);
        }
        /* ユーザーメニューの表示/非表示 */
        .user-menu-dropdown {
            position: absolute;
            top: 100%; /* アイコンの下に配置 */
            right: 0;
            z-index: 10;
            min-width: 180px; /* メニューの最小幅 */
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4 relative">
    <!-- ユーザーアイコンとメニュー -->
    <div class="absolute top-4 right-4 z-20">
        <button id="userMenuButton" class="bg-gray-700 hover:bg-gray-600 text-gray-200 p-2 rounded-full shadow-md focus:outline-none focus:ring-2 focus:ring-gray-500">
            <!-- ユーザーアイコン (例として👤を使用) -->
            <span class="text-2xl">👤</span>
        </button>
        <div id="userMenuDropdown" class="user-menu-dropdown bg-gray-800 p-4 rounded-lg shadow-xl hidden">
            <p id="authStatus" class="text-gray-200 text-sm mb-3 text-center"></p>
            <button id="googleSignInButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                Googleでログイン
            </button>
            <button id="signOutButton" class="w-full mt-2 bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-50 hidden">
                ログアウト
            </button>
        </div>
    </div>

    <div class="bg-gray-800 p-8 rounded-xl shadow-lg w-full max-w-md">
        <h1 class="text-3xl font-bold text-center text-gray-100 mb-6">英語読み上げサイト</h1>

        <div class="mb-6">
            <label for="textInput" class="block text-gray-200 text-sm font-semibold mb-2">
                読み上げたい英文を入力してください:
            </label>
            <textarea id="textInput" class="w-full p-3 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-y bg-gray-700 text-gray-100" rows="6" placeholder="例: Hello, how are you today?

This is a text-to-speech example with a pause between paragraphs."></textarea>
        </div>

        <!-- 速度調整スライダー -->
        <div class="mb-6">
            <label for="rateInput" class="block text-gray-200 text-sm font-semibold mb-2">
                読み上げ速度: <span id="rateValue" class="text-gray-100">1.0</span>
            </label>
            <input type="range" id="rateInput" min="0.5" max="2" value="1" step="0.1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
        </div>

        <!-- リピート設定 -->
        <div class="mb-6">
            <label for="repeatCount" class="block text-gray-200 text-sm font-semibold mb-2">
                リピート設定:
            </label>
            <select id="repeatCount" class="w-full p-3 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-700 text-gray-100">
                <option value="infinite">無限</option>
                <option value="1">1回</option>
                <option value="2">2回</option>
                <option value="3">3回</option>
                <option value="5">5回</option>
                <option value="10">10回</option>
            </select>
        </div>

        <div class="flex mb-4">
            <button id="readAloudButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                読み上げる
            </button>
        </div>

        <!-- 保存機能 -->
        <div class="mt-8 pt-4 border-t border-gray-700">
            <h2 class="text-2xl font-bold text-gray-100 mb-4">英文を保存</h2>
            <div class="mb-4">
                <label for="textTitleInput" class="block text-gray-200 text-sm font-semibold mb-2">
                    タイトル:
                </label>
                <input type="text" id="textTitleInput" class="w-full p-3 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-500 bg-gray-700 text-gray-100" placeholder="タイトルを入力">
            </div>
            <button id="saveTextButton" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-300 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50">
                英文を保存
            </button>
        </div>

        <!-- 保存された英文の表示 -->
        <div class="mt-8 pt-4 border-t border-gray-700">
            <h2 class="text-2xl font-bold text-gray-100 mb-4">保存された英文</h2>
            <!-- 並べ替えオプション -->
            <div class="mb-4">
                <label for="sortOrder" class="block text-gray-200 text-sm font-semibold mb-2">
                    並べ替え:
                </label>
                <select id="sortOrder" class="w-full p-3 border border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 bg-gray-700 text-gray-100">
                    <option value="newest">新しい順</option>
                    <option value="oldest">古い順</option>
                    <option value="titleAsc">タイトル順 (昇順)</option>
                    <option value="titleDesc">タイトル順 (降順)</option>
                </select>
            </div>
            <p id="userIdDisplay" class="text-gray-400 text-sm mb-4"></p>
            <div id="savedTextsContainer" class="space-y-4">
                <!-- 保存された英文がここに動的に追加されます -->
                <p class="text-gray-400 text-center" id="loadingMessage">読み込み中...</p>
            </div>
        </div>

        <!-- カスタム確認モーダル -->
        <div id="customConfirmModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 hidden">
            <div class="bg-gray-800 p-6 rounded-lg shadow-xl max-w-sm w-full">
                <p class="text-lg font-semibold text-gray-100 mb-4" id="confirmMessage"></p>
                <div class="flex justify-end space-x-3">
                    <button id="cancelConfirmBtn" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 text-gray-200 rounded-md transition duration-200">キャンセル</button>
                    <button id="okConfirmBtn" class="px-4 py-2 bg-red-700 hover:bg-red-800 text-white rounded-md transition duration-200">OK</button>
                </div>
            </div>
        </div>

        <div id="messageBox" class="mt-4 p-3 bg-red-900 border border-red-700 text-red-300 rounded-lg hidden" role="alert">
            <!-- エラーメッセージがここに表示されます -->
        </div>
    </div>

    <!-- Firebase SDKを読み込む -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // DOM要素を取得
        const textInput = document.getElementById('textInput');
        const readAloudButton = document.getElementById('readAloudButton');
        const rateInput = document.getElementById('rateInput');
        const rateValueSpan = document.getElementById('rateValue');
        const messageBox = document.getElementById('messageBox');
        const textTitleInput = document.getElementById('textTitleInput');
        const saveTextButton = document.getElementById('saveTextButton');
        const savedTextsContainer = document.getElementById('savedTextsContainer');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const loadingMessage = document.getElementById('loadingMessage');
        const repeatCountSelect = document.getElementById('repeatCount');
        const sortOrderSelect = document.getElementById('sortOrder'); // 並べ替えオプション

        // Google認証関連のDOM要素
        const userMenuButton = document.getElementById('userMenuButton');
        const userMenuDropdown = document.getElementById('userMenuDropdown');
        const googleSignInButton = document.getElementById('googleSignInButton');
        const signOutButton = document.getElementById('signOutButton');
        const authStatusDisplay = document.getElementById('authStatus');

        let db;
        let auth;
        let userId = 'anonymous'; // 初期値
        let currentUtterance = null; // 現在の読み上げオブジェクトを保持

        // 段落読み上げ管理変数
        let currentParagraphs = []; // Array of { utterance, text } objects for the queue
        let currentParagraphIndex = 0;
        let isSpeechActive = false; // True if speech is ongoing or paused (managed by our queue)
        let currentRepeatIteration = 0; // 現在のリピート回数
        let totalRepeatCount = 0; // 設定されたリピート総数 (0 = 無限)

        // メッセージを表示する関数
        function showMessage(message, type = 'error') {
            messageBox.textContent = message;
            if (type === 'error') {
                messageBox.className = 'mt-4 p-3 bg-red-900 border border-red-700 text-red-300 rounded-lg';
            } else if (type === 'info') {
                messageBox.className = 'mt-4 p-3 bg-blue-900 border border-blue-700 text-blue-300 rounded-lg';
            } else if (type === 'success') {
                messageBox.className = 'mt-4 p-3 bg-green-900 border border-green-700 text-green-300 rounded-lg';
            }
            messageBox.classList.remove('hidden');
        }

        // メッセージを非表示にする関数
        function hideMessage() {
            messageBox.classList.add('hidden');
        }

        // 読み上げボタンの表示状態を更新する関数
        function updateReadAloudButtonState() {
            if (window.speechSynthesis.speaking) {
                if (window.speechSynthesis.paused) {
                    readAloudButton.textContent = '再開';
                    readAloudButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                    readAloudButton.classList.add('bg-orange-600', 'hover:bg-orange-700');
                } else {
                    readAloudButton.textContent = '一時停止';
                    readAloudButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                    readAloudButton.classList.add('bg-orange-600', 'hover:bg-orange-700');
                }
            } else {
                readAloudButton.textContent = '読み上げる';
                readAloudButton.classList.remove('bg-orange-600', 'hover:bg-orange-700');
                readAloudButton.classList.add('bg-blue-600', 'hover:bg-blue-700');
            }
        }

        // Firebaseの初期化と認証
        async function initializeFirebase() {
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // 認証状態の変更を監視
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        if (user.isAnonymous) {
                            authStatusDisplay.textContent = `匿名ユーザー`;
                            userIdDisplay.textContent = `ユーザーID: ${userId}`;
                            googleSignInButton.classList.remove('hidden');
                            signOutButton.classList.add('hidden');
                        } else {
                            authStatusDisplay.textContent = `ログイン中: ${user.displayName || user.email}`;
                            userIdDisplay.textContent = `ユーザーID: ${userId}`; // GoogleログインでもUIDは表示
                            googleSignInButton.classList.add('hidden');
                            signOutButton.classList.remove('hidden');
                        }
                        console.log("Authenticated user ID:", userId);
                        // 認証完了後に保存されたテキストを読み込む
                        loadSavedTexts();
                    } else {
                        // ユーザーがログアウトした場合、または初期ロード時に認証されていない場合
                        authStatusDisplay.textContent = '未ログイン';
                        userIdDisplay.textContent = ''; // ユーザーIDをクリア
                        googleSignInButton.classList.remove('hidden');
                        signOutButton.classList.add('hidden');
                        // __initial_auth_token があればそれを使用、なければ匿名認証
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await signInWithCustomToken(auth, __initial_auth_token);
                        } else {
                            console.log("No initial auth token. Waiting for user action or session restore.");
                            userId = crypto.randomUUID(); // 仮の匿名ID
                            userIdDisplay.textContent = `ユーザーID: ${userId} (仮)`;
                            loadSavedTexts(); // 匿名ユーザーとしてデータロードを試みる
                        }
                    }
                });
            } catch (error) {
                console.error("Firebase initialization error:", error);
                showMessage("Firebaseの初期化に失敗しました。アプリが正しく動作しない可能性があります。", "error");
            }
        }

        // Googleでログインする関数
        async function signInWithGoogle() {
            hideMessage();
            try {
                const provider = new GoogleAuthProvider();
                await signInWithPopup(auth, provider);
                showMessage('Googleアカウントでログインしました。', 'success');
                userMenuDropdown.classList.add('hidden'); // ログイン後メニューを非表示
            } catch (error) {
                console.error("Google Sign-In Error:", error);
                let errorMessage = 'Googleログイン中にエラーが発生しました。';
                if (error.code === 'auth/popup-closed-by-user') {
                    errorMessage = 'Googleログインのポップアップが閉じられました。';
                } else if (error.code === 'auth/cancelled-popup-request') {
                    errorMessage = '既にポップアップが開かれています。';
                }
                showMessage(errorMessage, 'error');
            }
        }

        // ログアウトする関数
        async function signOutUser() {
            hideMessage();
            try {
                // 現在の読み上げを停止
                window.speechSynthesis.cancel();
                isSpeechActive = false;
                currentUtterance = null;
                currentParagraphs = [];
                currentParagraphIndex = 0;
                currentRepeatIteration = 0;
                updateReadAloudButtonState();

                await signOut(auth);
                showMessage('ログアウトしました。', 'info');
                // ログアウト後、匿名認証に切り替える
                await signInAnonymously(auth);
                userMenuDropdown.classList.add('hidden'); // ログアウト後メニューを非表示
            } catch (error) {
                console.error("Sign Out Error:", error);
                showMessage('ログアウト中にエラーが発生しました。', 'error');
            }
        }


        // 段落を順に読み上げる再帰関数
        function speakParagraphs() {
            // isSpeechActiveがfalseの場合（外部からキャンセルされた場合など）、キューの処理を停止
            if (!isSpeechActive) {
                console.log("Speech queue cancelled externally.");
                currentUtterance = null;
                updateReadAloudButtonState();
                currentParagraphs = [];
                currentParagraphIndex = 0;
                currentRepeatIteration = 0;
                return;
            }

            // 現在の段落がそのリピートサイクルの最後の段落に到達した場合
            if (currentParagraphIndex >= currentParagraphs.length) {
                currentRepeatIteration++; // リピート回数をインクリメント
                console.log(`Finished iteration ${currentRepeatIteration}`);

                // 無限リピートでない、かつ設定されたリピート回数に達した場合
                if (totalRepeatCount !== 0 && currentRepeatIteration >= totalRepeatCount) {
                    showMessage('読み上げが完了しました。', 'info');
                    currentUtterance = null;
                    isSpeechActive = false;
                    updateReadAloudButtonState();
                    currentParagraphs = [];
                    currentParagraphIndex = 0;
                    currentRepeatIteration = 0;
                    return;
                } else {
                    // 次のリピートサイクルを開始
                    currentParagraphIndex = 0; // 段落インデックスをリセット
                    // リピート間のポーズ
                    setTimeout(() => {
                        speakParagraphs(); // 次のリピートサイクルを開始
                    }, 1000); // リピート間のポーズ時間（1秒）
                    return;
                }
            }

            const { utterance, text } = currentParagraphs[currentParagraphIndex];
            currentUtterance = utterance; // グローバルなcurrentUtteranceを現在読み上げ中のものに設定

            utterance.onend = function() {
                console.log(`Finished speaking paragraph ${currentParagraphIndex + 1} in iteration ${currentRepeatIteration + 1}: "${text.substring(0, Math.min(text.length, 30))}..."`);
                // 読み上げがアクティブな場合のみ次の段落へ進む
                if (isSpeechActive) {
                    // 次の段落の前にポーズを挿入
                    setTimeout(() => {
                        currentParagraphIndex++;
                        speakParagraphs(); // 次の段落を読み上げ
                    }, 700); // 段落間のポーズの時間（ミリ秒単位、必要に応じて調整）
                }
            };

            utterance.onerror = function(event) {
                console.error('SpeechSynthesisUtterance.onerror for paragraph:', event);
                showMessage('読み上げ中にエラーが発生しました: ' + event.error, 'error');
                currentUtterance = null;
                isSpeechActive = false;
                updateReadAloudButtonState();
                currentParagraphs = [];
                currentParagraphIndex = 0;
                currentRepeatIteration = 0;
            };

            window.speechSynthesis.speak(utterance);
            updateReadAloudButtonState(); // ボタンの状態を「一時停止」に更新
        }


        // 読み上げ処理を実行する関数 (一時停止/再開機能を含む)
        function readAloud() {
            hideMessage();
            const inputText = textInput.value.trim();
            const rate = parseFloat(rateInput.value);
            const selectedRepeat = repeatCountSelect.value;

            if (inputText === '') {
                showMessage('読み上げる英文を入力してください。', 'error');
                return;
            }

            if (!('speechSynthesis' in window)) {
                showMessage('お使いのブラウザは音声合成APIをサポートしていません。最新のChromeやFirefoxをお試しください。', 'error');
                return;
            }

            // 現在読み上げ中で一時停止状態でない場合、一時停止する
            if (window.speechSynthesis.speaking && !window.speechSynthesis.paused) {
                window.speechSynthesis.pause();
                updateReadAloudButtonState();
                showMessage('読み上げを一時停止しました。', 'info');
                return;
            }

            // 現在一時停止中の場合、再開する
            if (window.speechSynthesis.paused) {
                window.speechSynthesis.resume();
                updateReadAloudButtonState();
                showMessage('読み上げを再開しました。', 'info');
                return;
            }

            // 読み上げ中でない、または停止中の場合、新しい読み上げを開始する
            // 既存の読み上げやキュー内のすべての発話を即座にキャンセル
            window.speechSynthesis.cancel();
            currentUtterance = null; // 以前の発話参照をクリア
            currentParagraphs = []; // 以前の段落キューをクリア
            currentParagraphIndex = 0;
            currentRepeatIteration = 0; // リピート回数をリセット
            isSpeechActive = true; // 新しいキューのために読み上げをアクティブとしてマーク

            // リピート設定を数値に変換
            if (selectedRepeat === 'infinite') {
                totalRepeatCount = 0; // 0は無限リピートを示す
            } else {
                totalRepeatCount = parseInt(selectedRepeat, 10);
            }

            // 2つ以上の改行文字でテキストを段落に分割
            const paragraphs = inputText.split(/\n{2,}/).filter(p => p.trim() !== '');

            if (paragraphs.length === 0) {
                showMessage('読み上げる内容がありません。', 'error');
                isSpeechActive = false; // 読み上げるコンテンツがない
                updateReadAloudButtonState(); // ボタンが「読み上げる」状態であることを確認
                return;
            }

            // 各段落に対してSpeechSynthesisUtteranceオブジェクトを作成し、キューに追加
            paragraphs.forEach(paragraphText => {
                const utterance = new SpeechSynthesisUtterance(paragraphText.trim());
                utterance.lang = 'en-US';
                utterance.rate = rate;
                utterance.pitch = 1;
                currentParagraphs.push({ utterance: utterance, text: paragraphText.trim() });
            });

            speakParagraphs(); // キューの最初の段落の読み上げを開始
            // 読み上げが実際に開始されたかを確認するための遅延チェック
            setTimeout(() => {
                // 短い遅延後も読み上げが開始されておらず、かつキューがアクティブな場合、何らかの問題が発生
                if (!window.speechSynthesis.speaking && isSpeechActive) {
                    showMessage('読み上げを開始できませんでした。ブラウザの問題かもしれません。', 'error');
                    // 読み上げ開始に失敗した場合、状態をクリーンアップ
                    isSpeechActive = false;
                    currentUtterance = null;
                    currentParagraphs = [];
                    currentParagraphIndex = 0;
                    currentRepeatIteration = 0;
                    updateReadAloudButtonState();
                }
            }, 200);
        }

        // 英文をFirestoreに保存する関数
        async function saveText() {
            hideMessage();
            const text = textInput.value.trim();
            const title = textTitleInput.value.trim(); // タイトルを取得

            if (text === '') {
                showMessage('保存する英文を入力してください。', 'error');
                return;
            }
            if (title === '') {
                showMessage('英文のタイトルを入力してください。', 'error');
                return;
            }

            if (!db || !userId) {
                showMessage('データベースが利用できません。しばらくお待ちください。', 'error');
                return;
            }

            try {
                const textsCollectionRef = collection(db, `artifacts/${__app_id}/users/${userId}/spoken_texts`);
                await addDoc(textsCollectionRef, {
                    text: text,
                    // Firestoreのフィールド名は既存のデータ互換性のため'category'のまま
                    category: title, // UI上はタイトルだが、DB上はcategoryとして保存
                    timestamp: serverTimestamp() // サーバーのタイムスタンプを使用
                });
                showMessage('英文を保存しました！', 'success');
                textTitleInput.value = ''; // タイトル入力欄をクリア
            } catch (e) {
                console.error("Error adding document: ", e);
                showMessage('英文の保存中にエラーが発生しました。', 'error');
            }
        }

        // 保存された英文をFirestoreから読み込み、表示する関数
        function loadSavedTexts() {
            if (!db || !userId) {
                // Firebaseがまだ初期化されていないか、ユーザーIDが取得できていない場合は何もしない
                return;
            }

            const textsCollectionRef = collection(db, `artifacts/${__app_id}/users/${userId}/spoken_texts`);
            const q = query(textsCollectionRef); // orderByは使用せず、JavaScriptでソート

            onSnapshot(q, (snapshot) => {
                savedTextsContainer.innerHTML = ''; // 既存のリストをクリア
                loadingMessage.classList.add('hidden'); // ローディングメッセージを非表示

                if (snapshot.empty) {
                    savedTextsContainer.innerHTML = '<p class="text-gray-400 text-center">保存された英文はありません。</p>';
                    return;
                }

                const texts = [];
                snapshot.forEach((doc) => {
                    texts.push({ id: doc.id, ...doc.data() });
                });

                // 並べ替えロジック
                const sortOrder = sortOrderSelect.value;
                texts.sort((a, b) => {
                    if (sortOrder === 'newest') {
                        const timeA = a.timestamp ? a.timestamp.toDate().getTime() : 0;
                        const timeB = b.timestamp ? b.timestamp.toDate().getTime() : 0;
                        return timeB - timeA; // 降順
                    } else if (sortOrder === 'oldest') {
                        const timeA = a.timestamp ? a.timestamp.toDate().getTime() : 0;
                        const timeB = b.timestamp ? b.timestamp.toDate().getTime() : 0;
                        return timeA - timeB; // 昇順
                    } else if (sortOrder === 'titleAsc') {
                        const titleA = (a.category || 'タイトルなし').toLowerCase();
                        const titleB = (b.category || 'タイトルなし').toLowerCase();
                        return titleA.localeCompare(titleB); // 昇順
                    } else if (sortOrder === 'titleDesc') {
                        const titleA = (a.category || 'タイトルなし').toLowerCase();
                        const titleB = (b.category || 'タイトルなし').toLowerCase();
                        return titleB.localeCompare(titleA); // 降順
                    }
                    return 0;
                });

                // タイトル（旧カテゴリ）ごとにグループ化
                const categorizedTexts = texts.reduce((acc, item) => {
                    // UI上はタイトルとして扱うが、DBのフィールド名は'category'のまま
                    const title = item.category || 'タイトルなし';
                    if (!acc[title]) {
                        acc[title] = [];
                    }
                    acc[title].push(item);
                    return acc;
                }, {});

                // タイトルと英文を表示
                for (const title in categorizedTexts) {
                    const categoryDiv = document.createElement('div');
                    categoryDiv.className = 'bg-gray-700 p-3 rounded-lg mb-4';
                    categoryDiv.innerHTML = `
                        <h3 class="text-lg font-semibold text-gray-100 flex justify-between items-center cursor-pointer category-header">
                            ${title}
                            <span class="text-gray-400 text-sm transform transition-transform duration-200 category-toggle-icon">▼</span>
                        </h3>
                        <div class="texts-in-category hidden mt-2 space-y-2"></div> <!-- テキストを格納するコンテナ、最初は非表示 -->
                    `;
                    const textsInThisCategoryDiv = categoryDiv.querySelector('.texts-in-category');
                    const toggleIcon = categoryDiv.querySelector('.category-toggle-icon');

                    // タイトルヘッダーのクリックイベントリスナー
                    categoryDiv.querySelector('.category-header').addEventListener('click', () => {
                        textsInThisCategoryDiv.classList.toggle('hidden');
                        toggleIcon.classList.toggle('rotate-180'); // 矢印アイコンを回転
                    });

                    categorizedTexts[title].forEach(item => {
                        const textItemDiv = document.createElement('div');
                        textItemDiv.className = 'bg-gray-600 p-3 rounded-lg shadow-sm flex flex-col sm:flex-row items-start sm:items-center justify-between';
                        textItemDiv.innerHTML = `
                            <p class="text-gray-200 text-sm flex-grow mb-2 sm:mb-0">${item.text.substring(0, 50)}${item.text.length > 50 ? '...' : ''}</p> <!-- 英文の冒頭50文字を表示 -->
                            <div class="flex space-x-2 mt-2 sm:mt-0">
                                <button data-text="${item.text}" class="view-saved-text-btn bg-blue-600 hover:bg-blue-700 text-white text-xs px-3 py-1 rounded-md transition duration-200">表示</button>
                                <button data-id="${item.id}" class="delete-saved-text-btn bg-red-700 hover:bg-red-800 text-white text-xs px-3 py-1 rounded-md transition duration-200">削除</button>
                            </div>
                        `;
                        textsInThisCategoryDiv.appendChild(textItemDiv);
                    });
                    savedTextsContainer.appendChild(categoryDiv);
                }

                // 「表示」ボタンのイベントリスナーを設定
                document.querySelectorAll('.view-saved-text-btn').forEach(button => {
                    button.onclick = (event) => {
                        textInput.value = event.target.dataset.text; // テキストエリアに全文をセット
                        hideMessage(); // メッセージをクリア
                        // ここでは自動で読み上げは開始せず、ユーザーがメインの「読み上げる」ボタンをクリックする
                    };
                });

                // 削除ボタンのイベントリスナーを設定
                document.querySelectorAll('.delete-saved-text-btn').forEach(button => {
                    button.onclick = (event) => {
                        const docId = event.target.dataset.id;
                        showCustomConfirm('この英文を削除しますか？', async () => {
                            await deleteText(docId);
                        });
                    };
                });
            }, (error) => {
                console.error("Error fetching documents: ", error);
                showMessage('保存された英文の読み込み中にエラーが発生しました。', 'error');
                loadingMessage.classList.add('hidden');
                savedTextsContainer.innerHTML = '<p class="text-gray-400 text-center">読み込みに失敗しました。</p>';
            });
        }

        // 英文をFirestoreから削除する関数
        async function deleteText(docId) {
            hideMessage();
            if (!db || !userId) {
                showMessage('データベースが利用できません。しばらくお待ちください。', 'error');
                return;
            }
            try {
                const docRef = doc(db, `artifacts/${__app_id}/users/${userId}/spoken_texts`, docId);
                await deleteDoc(docRef);
                showMessage('英文を削除しました。', 'success');
            } catch (e) {
                console.error("Error deleting document: ", e);
                showMessage('英文の削除中にエラーが発生しました。', 'error');
            }
        }

        // 現在のテキストをtxtファイルとしてダウンロードする関数
        function downloadText() {
            hideMessage();
            const text = textInput.value.trim();
            if (text === '') {
                showMessage('ダウンロードする英文がありません。', 'error');
                return;
            }

            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'spoken_text.txt';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href); // URLを解放
            showMessage('英文をダウンロードしました。', 'info');
        }

        // カスタム確認モーダルを表示する関数
        function showCustomConfirm(message, onConfirm) {
            const modal = document.getElementById('customConfirmModal');
            document.getElementById('confirmMessage').textContent = message;
            modal.classList.remove('hidden');

            const okBtn = document.getElementById('okConfirmBtn');
            const cancelBtn = document.getElementById('cancelConfirmBtn');

            const cleanup = () => {
                okBtn.onclick = null;
                cancelBtn.onclick = null;
                modal.classList.add('hidden');
            };

            okBtn.onclick = () => {
                onConfirm();
                cleanup();
            };

            cancelBtn.onclick = () => {
                cleanup();
            };
        }

        // イベントリスナーの設定
        readAloudButton.addEventListener('click', readAloud);
        saveTextButton.addEventListener('click', saveText);
        rateInput.addEventListener('input', () => {
            rateValueSpan.textContent = rateInput.value;
        });

        // ユーザーメニューボタンのイベントリスナー
        userMenuButton.addEventListener('click', () => {
            userMenuDropdown.classList.toggle('hidden');
        });

        // Google認証ボタンのイベントリスナー
        googleSignInButton.addEventListener('click', signInWithGoogle);
        signOutButton.addEventListener('click', signOutUser);

        // 並べ替えオプションの変更時に再読み込み
        sortOrderSelect.addEventListener('change', loadSavedTexts);

        // Firebaseの初期化とデータ読み込みを開始
        initializeFirebase();
    </script>
</body>
</html>
